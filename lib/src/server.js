import fs from 'fs'
import path from 'path'
import getPort from 'get-port'
import {fileURLToPath} from 'url'
import express from 'express'
import {createServer as createViteServer} from 'vite'
import {glob} from 'glob'
import puppeteer from 'puppeteer'
import {PNG} from 'pngjs'
import pixelmatch from 'pixelmatch'
import {info, error, warning} from './chalkTheme.js'
import chalk from "chalk";
import {RENDERER_PATH} from "./global.js";

const __dirname = path.dirname(fileURLToPath(import.meta.url))

function getScreenshotPath(opts) {
    return opts.path.replace('<root>', process.cwd()).replaceAll('\\', '/')
}
function getRenderer(componentsPaths) {
    const getComponentName = (componentPath) =>
        path.basename(componentPath).split('.')[0]

    const imports = componentsPaths.reduce(
        (acc, componentPath) =>
            acc +
            `import ${getComponentName(componentPath)} from './${componentPath.replaceAll('\\', '/')}'`,
        ''
    )
    const componentsArray = '[' + componentsPaths.map(pth => getComponentName(pth)).join(', ') + ']'
    const componentNamesArray = "['" + componentsPaths.map(pth => getComponentName(pth)).join("', '") + "']"

    return `// this file is autogenerated by vshot
${imports}

import { createApp } from 'vue'

const components = ${componentsArray}
const names = ${componentNamesArray}

async function render(scene) {
    document.querySelector('#app').innerHTML = ''

    const app = createApp(scene.component, {scene: scene.scene})
    if (scene.component.onAppCreated) {
        scene.component.onAppCreated(app, window)
    }

    try {
        app.mount('#app')
    } catch (e) {
        import.meta.hot.send('vshot:error', { error: e.message })
    }
    
    if (scene.component.beforeScreenshot) {
        await scene.component.beforeScreenshot(document.getElementById('app'), scene.scene)
    }
    
    return app
}

let id = 0
let scenes = []
for(let i in components) {
    const c = components[i]
    if (c.scenes) {
        c.scenes.forEach(s => scenes.push({component: c, scene: s, componentName: names[i]}))
    } else {
        scenes.push({component: c, scene: 'default', componentName: names[i]})
    }
}

let app = null

try {
    import.meta.hot.on('vshot:next', async () => {
        if (id >= scenes.length) {
            import.meta.hot.send('vshot:finish')
            return
        }
        
        if (app) {
            app.unmount()
        }
        
        app = await render(scenes[id])
        
        import.meta.hot.send('vshot:ready', scenes[id])
        
        id += 1
    })
} catch(e) {
    import.meta.hot.send('vshot:error', { error: e })
}`
}

function createIfNotExists(dir) {
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir)
    }
}

async function takeScreenshots(port, vite, opts) {
    puppeteer.configuration.logLevel = 'error'

    console.log(info(`setting up browser\nPORT: ${port}`))

    const browser = await puppeteer.launch()
    const page = await browser.newPage()
    await page.setViewport({width: 1592, height: 878})
    await page.goto(`http://localhost:${port}`)

    console.log(info('page loaded'))

    if (opts.approve) {
        if (fs.existsSync(getScreenshotPath(opts) + '/current')) fs.rmSync(getScreenshotPath(opts) + '/current', {
            recursive: true,
            force: true
        })
        if (fs.existsSync(getScreenshotPath(opts) + '/diff')) fs.rmSync(getScreenshotPath(opts) + '/diff', {
            recursive: true,
            force: true
        })
    }

    const takeScreenshot = async (data, client) => {
        const saveTo = (dir) => `${getScreenshotPath(opts)}/${dir}/${data.componentName}_${data.scene}.png`
        if (opts.approve || !fs.existsSync(saveTo('ref'))) {
            // write/overwrite new screenshot
            await page.screenshot({
                path: saveTo('ref'),
                fullPage: true,
            })

            console.log(chalk.bold.bgBlue(' SAVED '), info(data.componentName + ':', data.scene))
        } else {
            createIfNotExists(getScreenshotPath(opts) + '/current')

            await page.screenshot({
                path: saveTo('current'),
                fullPage: true,
            })

            const ref = PNG.sync.read(fs.readFileSync(saveTo('ref')))
            const current = PNG.sync.read(fs.readFileSync(saveTo('current')))
            const {width, height} = ref
            const diff = new PNG({width, height})

            const diffPixels = pixelmatch(ref.data, current.data, diff.data, width, height, {threshold: 0.1})

            if (diffPixels) {
                createIfNotExists(getScreenshotPath(opts) + '/diff')
                fs.writeFileSync(saveTo('diff'), PNG.sync.write(diff))

                console.log(chalk.bold.bgRed(' FAIL '), info(data.componentName + ':', data.scene))
            } else {
                if (fs.existsSync(saveTo('diff'))) fs.unlinkSync(saveTo('diff'))

                console.log(chalk.bold.bgGreen(' PASS '), info(data.componentName + ':', data.scene))
            }
        }

        vite.ws.send('vshot:next')
    }

    vite.ws.on('vshot:ready', takeScreenshot)

    // start renderer
    vite.ws.send('vshot:next')

    // wait for finish
    await new Promise(resolve => {
        vite.ws.on('vshot:finish', () => {
            browser.close()
            vite.ws.off('vshot:ready', takeScreenshot)
            resolve()
        })
    })
}

export async function createServer(opts) {
    createIfNotExists(getScreenshotPath(opts))
    createIfNotExists(getScreenshotPath(opts) + '/ref')


    const relativeFilePaths = await glob(opts.pattern, {
        ignore: '**/node_modules/**',
        cwd: process.cwd(),
    })

    if (relativeFilePaths.length === 0) {
        console.log(warning(`No files found matching pattern: "${opts.pattern}"`))
        process.exit()
    }

    const rendererSrc = getRenderer(relativeFilePaths)
    fs.writeFileSync(RENDERER_PATH, rendererSrc)

    const app = express()

    const vite = await createViteServer({
        server: {middlewareMode: true},
        appType: 'custom',
    })

    vite.ws.on('vshot:error', (data, client) => {
        console.log(error(data.error))
    })

    app.use(vite.middlewares)

    app.use('*', async (req, res, next) => {
        const url = req.originalUrl

        try {
            let template = `
            <!doctype html>
            <html lang="en">
              <head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <title>vshot</title>
              </head>
              <body>
                <div id="app"></div>
                <script type="module" src="/__renderer__.js"></script>
              </body>
            </html>
            `

            template = await vite.transformIndexHtml(url, template)

            res.status(200).set({'Content-Type': 'text/html'}).end(template)
        } catch (e) {
            console.log(error(e))
            vite.ssrFixStacktrace(e)
            next(e)
        }
    })

    const port = await getPort({port: 57333})

    const server = app.listen({port})

    await takeScreenshots(
        port,
        vite,
        opts
    )

    // to avoid console logs when exit ???
    await new Promise(resolve => setTimeout(resolve, 2000))

    await vite.close()
    server.close()
}
